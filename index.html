<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="assests/style.css" />
    <title>Ответы на теоретические вопросы. 27 неделя. "События".</title>
  </head>
  <body>
    <div class="root">
      <h1>Привет, Кот. Мои ответы на теоретические вопросы за 27 неделю.</h1>
      <ol>
        <li>
          <span class="question"
            >Как вы думаете, чем плохо задание атрибута компонента key функцией
            Math.random()?</span
          >
          <p>Ответ: Задание атрибута key функцией Math.random() может иметь несколько негативных последствий:

            <p>1. Отсутствие уникальности: Функция Math.random() генерирует случайное число, но это число не является гарантированно уникальным для каждого элемента в списке. В результате может произойти дублирование ключей, что может нарушить работу React и привести к непредсказуемому поведению компонента.</p>
            
            <p>2. Потеря состояния: При каждой перерисовке компонента React использует ключи для определения изменений элементов. Если ключи не являются уникальными и стабильными, React может неправильно определить состояние каждого элемента, что приведет к некорректному отображению данных и потере состояния.</p>
            
            <p>3. Производительность: Math.random() является вычислительно затратной функцией, поэтому использование ее для генерации ключей в больших списках может снизить производительность приложения.</p>
          </p>
        </li>
        <li>
          <span class="question"
            >Как будет выглядеть этот пример, если мы кроме id будем передавать
            ещё один параметр title?</span
          >
          <p>Ответ:<br>
            <img src="assests/img/answer2.png" alt="ответ на 2 вопрос"><br>
          </p>
        </li>
        <li>
          <span class="question"
            >В чём отличие VirtualDOM от обычного DOM?</span
          >
          <p>Ответ: В отличие от DOM, виртуальный DOM не является официальной спецификацией, а представляет собой новый метод взаимодействия с DOM. Виртуальный DOM может рассматриваться как копия исходного DOM. Этой копией можно часто манипулировать и обновлять, не используя API DOM. После того, как все обновления были внесены в виртуальный DOM, мы можем посмотреть, какие конкретные изменения необходимо внести в исходный DOM, и сделать их целевым и оптимизированным способом. Фактически, виртуальный DOM — это просто обычный объект Javascript.</p>
        </li>
        <li>
          <span class="question"
            >В каком порядке выйдут сообщения в консоли и почему?<br />
            <img src="assests/img/question4.png" alt="вопрос 4" /><br />
          </span>
          <p>Ответ: Сообщения в консоли будут выводиться в следующем порядке:
            <ol>
              <li> "foo" - этот console.log() вызывается первым в теле функции handleChange и будет выведен сразу после вызова функции.
              </li>
              <li> "baz" - этот console.log() является коллбэком к методу setState и будет вызван после завершения обновления состояния. 
              </li>
              <li> "bar" - этот console.log() вызывается после метода setState, но до вызова коллбэка. Поэтому он будет выведен после выполнения обновления состояния, но до вызова коллбэка.
              </li>
            </ol>
          </p>
        </li>
        <li>
          <span class="question"
            >Какую проблему решает использование рефов?</span
          >
          <p>Ответ: Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе. В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы. Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами. Тем не менее, могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент, обойдя обычный поток данных. Подлежащий изменениям дочерний элемент может быть как React-компонентом, так и DOM-элементом. React предоставляет лазейку для обоих случаев.<br>
            Ситуации, в которых использование рефов является оправданным:

            Управление фокусом, выделение текста или воспроизведение медиа.
            Императивный вызов анимаций.
            Интеграция со сторонними DOM-библиотеками.
        </p>
        </li>
        <li>
          <span class="question"
            >Как вы думаете, почему вызов методов ребёнка из родительского
            компонента противоречит философии реакта?</span
          >
          <p>Ответ: в React поток данных односторонний и сходит сверху вниз в иерархическом порядке. Обратно только через колбэк функции. Родительский компонент не должен напрямую управлять методами или состоянием дочернего компонента, поскольку это приводит к сложности в отслеживании и понимании потока данных. Вместо этого, Реакт рекомендует использовать передачу пропсов из родительского компонента в дочерний и передавать колбэк функции из дочернего компонента в родительский компонент для обратного вызова.</p>
        </li>
        <li>
          <span class="question"
            >Можно ли с помощью хука useRef передать ref дочерним
            элементам?</span
          >
          <p>Ответ: используя только хук useRef передать ref дочерним компонентам нельзя. Для этого используется метод forwardRef, и им оборачивается весь компонент.</p>
        </li>
        <li>
          <span class="question"
            >Что даёт нам использование кастомных хуков?</span
          >
          <p>Ответ: если нам может понадобится сделать специфический хук с более сложной логикой, который мы не найдём в списке хуков реакта. В таком случае, можно написать его самим, используя хуки из коробки как основу.</p>
        </li>
      </ol>
    </div>
  </body>
</html>
